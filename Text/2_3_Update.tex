\subsection{Алгоритм обновления индекса}

Существуют две операции обновления индекса, которые требуют модификации индекса для отражения актуального состоянии, чтобы не допустить ложноотрицательных ответов. При добавлении, обновлении или удалении записей возможны два следующих случая сценария: 
\begin{enumerate}
    \item Добавление ключа $k$ в расположение $loc$.
    \item Удаление ключа $k$ из расположения $loc$.
\end{enumerate}

В дальнейшем будем называть упорядоченную пару $(k, loc)$ \textbf{индексной записью}.

Сито-индекс не хранит в себе индексные записи, так как использует совершенно другую структуру, описывающую промежуток ключей, этой структурой является блок. Однако определением {<<индексная запись>>} удобно оперировать в рамках операций обновления индекса.

Индекс должен поддерживать исторические запросы (\ref{subsec:requirements}), в параграфе \ref{subsec:systems_for_data_access} уже были описаны методы управления данными для их версионирования. На протяжении всей работы факт того, что для каждого файла может хранится несколько исторических версий был опущен, однако при рассмотрении операций обновления индекса этот процесс стоит рассмотреть детальнее. Для работы с историческими запросами индекс должен сам использовать ту же стратегию управления своим содержимым, что и пользовательские данные (\ref{subsec:systems_for_data_access}).

Исходя из структуры хранения сегментов Сито-индекса в хранилище данных возможно реализовать стратегии управления данных следующим образом:
\begin{enumerate}
    \item Для реализации стратегии {<<копирование при записи>>} при поступлении индексной записи генерируется новая версия файла с сегментом, которая создаётся путём слияния существующего сегмента с поступившими индексными записями.
    \item Для реализации стратегии {<<слияние при чтении>>} каждая поступающая индексная запись сохраняется в дельта-файл \fbox{ссылка}, каждый из которых ассоциирован с файлом сегмента. При компактизации пользовательской таблицы производится слияние файла сегмента и дельта файлов поступивших индексных записей, тот же процесс происходит и при обращении к индексу.
\end{enumerate}
Стратегия {<<Копирование при записи>>} является частным случаем стратегии {<<Слияние при чтении>>}, при котором процесс компактизации происходит сразу же, без создания дельта-файлов. В действительности, процесс управления данными индекса работает согласно этому же процессу для пользовательских данных (\ref{subsec:systems_for_data_access}).

Таким образом операция добавления или удаления индексной записи сводится к реализации процессу компактизации для сегмента и поступивших индексных записей. Данный процесс может происходить как для обновления индекса при реализации обеих стратегий управления данными, так и при чтении индекса (\ref{search}), чтобы получить актуальное состояние сегментов в запрашиваемый момент времени в историческом запросе.

\textbf{Алгоритм компактизации сегмента} $s$ и для поступившей индексной записи добавления $(k, loc)$:
\begin{enumerate}
\item Необходимо найти и считать блок $b$ (\ref{search}) из сегмента $s$, который содержит информацию о диапазоне ключей, в который входит ключ $k$.
\item Если расположение $loc$ уже присутствует в множестве расположений блока $b.L$, необходимо увеличить счетчик расположений $b.L(loc)$ на единицу. В данном случае вероятность ложноположительного ответа для данного блока не возрастает, так как расположение $loc$ уже присутствует в данном блоке.
\item Если расположение $loc$ отсутствует в множестве расположений блока $b.L$, то необходимо добавить его в это множество, а счетчик расположений $b.L(loc)$ установить равным $1$. Если размер блока $b_{size} > 1$ и это операция обновления индекса, то как минимум для одного ключа ответ по нему будет ложноположительный, количество дополнительных ложноположительных ответов сегмента $s$ увеличится: $s.e = s.e + b_{size} - 1$.   
\end{enumerate}

\textbf{Алгоритм компактизации сегмента} $s$ и для поступившей индексной записи удаления $(k, r)$:
\begin{enumerate}
\item Необходимо обнаружить блок $b$ (\ref{search}) из сегмента $s$, который содержит информацию о диапазоне ключей, в который входит ключ $k$.
\item Если счетчик расположений $b.R(r) = 1$, необходимо удалить расположение и его счетчик из множества расположений данного блока. Количество дополнительных ложноположительных ответов в данном случае не увеличивается.
\item Если счетчик расположений $b.R(r) > 1$, необходимо уменьшить его на единицу. Количество дополнительных ложноположительных ответов в данном случае не увеличивается.
\end{enumerate}

При достижении предела количества дополнительных ложноположительных ответов $s.e \geq s.E$, сегмент необходимо построить заново в соответствии с алгоритмом построения индекса (\ref{build})