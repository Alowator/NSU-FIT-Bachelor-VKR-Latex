\subsection{Устройство системы доступа к данным}\label{subsec:systems_for_data_access}

Для формирования требований к структуре данных, позволяющей ускорить выполнение интервальных запросов путем отсеивания файлов c данными, не удовлетворяющими предикату, необходимо определить ключевые моменты устройства систем для доступа к данным в платформах для обработки больших данных, чтобы сформировать ряд ограничений, которые существуют при реализации структур данных в таких системах. Системы для доступа к данным используют одинаковые стратегии управления данными, поэтому, без ограничения общности~\cite{Analyzing_and_comparing_lakehouse_storage_systems}, рассмотрим в данной работе устройство одной из таких систем --- \textbf{Apache Hudi}~\cite{Analyzing_and_comparing_lakehouse_storage_systems}.

Apache Hudi (далее --- Hudi) организует данные в таблицы, реализуя тем самым реляционную модель~\cite{Database_systems_Garcia_Molina}. Hudi поддерживает работу с историческими запросами: при обновлении данных создается новый снимок обновленных данных в виде отдельного файла, в то время как предыдущий остается доступным для исторических запросов. Каждой операции, изменяющей состояние данных, присваивается уникальная отметка на временной шкале. Используя концепцию временной шкалы, Hudi реализует журналирование всех операций над данным~\cite{A_Logic_of_File_Systems}, используя этот журнал, реализуются различные стратегии управления параллельным доступом к данным. На каждый момент времени приходится не более одного действия, что создает линейный порядок на всех операциях над таблицей. Каждое действие в журнале содержит информацию о времени (с точностью до миллисекунд), типе и состоянии операции. Каждой операции на шкале времени присуще одно из состояний: «запланировано», «в процессе» или «завершено». Таким образом, временная шкала --- одна из основополагающих концепций для управления данными в Hudi~\cite{Hudi_Timeline}.

В каждой таблице Hudi существует служебная директория, в которой находится вся метаинформация и журнал (временная шкала), необходимые для обслуживания данных. Метаданные организованы в виде таблиц, которые  являются такими же таблицами Hudi, только вложенными в пользовательскую таблицу и скрытыми от пользователя. Эти таблицы находятся в служебной директории внутри директории с пользовательской таблицей, но недоступны для пользователя~\cite{Hudi_Metadata}. Именно в служебных таблицах хранятся существующие в Hudi структуры данных, такие как фильтр Блума и упрощенные сводки (о структуре которых изложено в разделе \ref{subsec:indexes}). Такой подход является приемлемой практикой и используется в самых распространенных системах для доступа к данным~\cite{Extensible_data_skipping}.

В системах для доступа к данным существует две стратегии обновления данных, которые определяют внутреннюю структуру таблицы~\cite{Analyzing_and_comparing_lakehouse_storage_systems}, которую необходимо рассмотреть, чтобы сформировать представление о том, какие файлы необходимо индексировать для решения задачи отсеивания нерелевантных файлов: 
\begin{enumerate}
    \item \textbf{Копирование при записи} --- при таком подходе данные хранятся в файлах большого размера, в формате, оптимизированном для более быстрого чтения. При операции записи генерируется новая версия файла данных, которая создается путем слияния существующего файла данных с новыми поступившими данными. Такой подход обеспечивает быстрое чтение данных, однако запись данных становится медленной, так как при каждом обновлении необходимо копировать файл с данными большого размера~\cite{Analyzing_and_comparing_lakehouse_storage_systems}.
    \item \textbf{Слияние при чтении} --- подход, при котором каждая операция записи данных создает отдельный файл небольшого размера, в котором хранятся не все данные, а только изменения, внесенные операцией обновления, такие файлы оптимизированы для быстрой записи и называются \textbf{дельта-файлами}. При чтении необходимо считывание всех данных дельта-файлов для формирования результата, такой подход обеспечивает более быструю запись, однако чтение данных становится медленным, так как необходимо считывать множество файлов и производить слияние данных их дельта-файлов при каждом чтении. Такой подход имеет особенность --- очевидно, что нельзя допустить неограниченный рост количества дельта-файлов, поэтому при достижении определенного порога количества дельта-файлов, происходит процесс \textbf{компактизации} --- слияния множества дельта-файлов в один файл большого размера, в формат, оптимизированный для чтения~\cite{Analyzing_and_comparing_lakehouse_storage_systems}. 
\end{enumerate}
Стратегия {<<Копирование при записи>>} является частным случаем стратегии {<<Слияние при чтении>>}, при которой порог количества дельта-файлов равен нулю, а процесс компактизации происходит при каждой записи.

Устройство Hudi полностью реализует обе стратегии обновления данных следующим образом: для каждой стратегии существует тип таблицы с соответствующим названием. Тип таблицы задается при ее создании, а управление процессом обновления данных для каждого типа таблицы происходит по соответствующей стратегии, как описано выше~\cite{Hudi_Table_types}.

Размер таблицы увеличивается при добавлении данных, как и размер файлов. Для размера файла существует предел, так как для реализации обеих стратегий необходимо создавать файлы, размер которых постоянно растет. Очевидно, что для реализации каждой из стратегий, необходимо иметь множество файлов с данными, каждый из которых содержит определенную часть из набора данных, который содержится в таблице. Таким образом, процесс обновления данных для каждой из стратегий происходит более эффективно. Так как системы доступа к данным поддерживают возможность исторических запросов, то каждый из файлов с данными представлен в нескольких вариантах, каждый из которых отвечает определенной отметке времени. Множество этих файлов называется \textbf{файловой группой}. При достижении заданного конфигурируемого предела размера файла в файловой группе, формируется новая файловая группа. Независимо от типа таблицы, каждый файл данных ассоциирован с определенной файловой группой, а каждая файловая группа обладает уникальным случайно генерируемым идентификатором~\cite{Hudi_File_layouts}.

Структура данных, представляющая собой фильтр для отсеивания нерелевантных файлов, обновляется синхронно с обновлением набора данных в таблице, это необходимо чтобы не допустить потери данных при неверном отсеивании файлов. Соответственно, \textbf{таблица, содержащая фильтр, должна реализовывать ту же стратегию управления данными, что и пользовательская таблица}. Это верно, так как каждая операция записи в таблицу требует записи в фильтр, а каждая операция чтения данных требует чтение фильтра.

Файловые группы расположены в директориях файловой системы, путь к директории называется \textbf{партицией}. Партиция генерируется на основе заданной пользователем схемы партиционирования. Схема партиционирования включает в себя список атрибутов таблицы, значения которых определяют путь расположения файловой группы~\cite{Hudi_File_layouts}. Партиционирование в системах для доступа к данным необходимо для решения множества задач, в том числе для ускорения интервальных запросов --- необходимо отсеивать те пути к файловым группам, значение атрибута в которых не удовлетворяет предикату запроса. Данный подход является тривиальным, имеет множество ограничений и уже реализован в системах для доступа к данным~\cite{Spatial_big_data_architecture}, поэтому не рассматривается в данной работе.

Учитывая организацию файлов в системах для доступа к данным, можно прийти к выводу, что в действительности фильтр должен отсеивать не конкретные файлы с данными, а файловые группы, в силу того, что запрос может быть историческим. Выбор конкретной версии файла из файловой группы зависит от момента времени исторического запроса, поэтому введем следующее определение.

\begin{definition}\label{def:location}
    \textbf{Расположение файла} (или расположение) --- это упорядоченная пара $($партиция, идентификатор файловой группы$)$, которая однозначно определяет расположение файловой группы, выбор же конкретного файла из файловой группы зависит от момента времени, запрашиваемого в историческом запросе, этот процесс не зависит от условия интервального запроса, поэтому в дальнейшем в данной работе говоря о расположении файла, будем иметь ввиду именно партицию и файловую группу, а не конкретный файл. 
\end{definition}
