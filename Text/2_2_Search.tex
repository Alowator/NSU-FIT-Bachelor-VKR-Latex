\subsection{Алгоритм поиска в Сито-индексе}\label{subsec:search}

Для поиска расположений файлов, в которых содержатся ключи, удовлетворяющие предикату запроса, в первую очередь, необходимо прочитать метаданные индекса, в которых содержится информация о существующих сегментах индекса, чтобы получить список сегментов $S$.

Поиск расположений для точечного запроса схож с алгоритмом поиска, используемом для структуры данных Sieve~\cite{Sieve}.

\textbf{Алгоритм поиска расположений для точечного запроса по ключу $k$:}

На входе: ключ $k$.

На выходе: множество расположений ключа $k$.
\begin{enumerate}
    \item Список сегментов является отсортированным, $N$ - количество сегментов в индексе. Сегмент $s$, содержащий информацию о ключе $k$, находится бинарным поиском по списку сегментов время $O(logN)$.
    \item Сегмент $s$, содержащий информацию о ключе $k$, загружается из хранилища данных.
    \item Чтобы в загруженном массиве найти блок, содержащий расположения файлов, в которых присутствует ключ $k$, за время $O(1)$ вычислим номер соответствующего блока $b_{i} = \frac{k - s_{min}}{b_{size}}$.
    \item Список расположений из полученного блока $loc = b_{i}.L$ --- есть множество расположений, которые необходимо проверить при выполнении запроса.
\end{enumerate}

Далее разработаем алгоритм обработки интервального запроса.

\textbf{Алгоритм поиска расположений для интервального запроса по ключам из интервала $[l, r]$:}

На входе: ключи $l, r$.

На выходе: множество расположений ключей из интервала $[l, r]$.
\begin{enumerate}
    \item Список сегментов является отсортированным, $N$ - количество сегментов в индексе. Сегмент $s$, содержащий информацию о ключе $l$, находится бинарным поиском по списку сегментов время $O(logN)$.
    \item Сегмент $s$, содержащий информацию о ключе $l$, загружается из хранилища данных.
    \item Чтобы в загруженном массиве найти блок, содержащий расположения файлов, в которых присутствует ключ $k$, за время $O(1)$ вычислим номер соответствующего блока $b_{i} = \frac{l - s_{min}}{b_{size}}$.
    \item Далее последовательно считываем следующие за ним блоки, пока для очередного блока выполняется $r \leq b_{max}$, если не выполняется, алгоритм завершен.
    \item После чтения последнего блока в сегменте, переходим к чтению блоков из следующего сегмента (шаг 4), предыдущий сегмент может быть выгружен из памяти.
\end{enumerate}
