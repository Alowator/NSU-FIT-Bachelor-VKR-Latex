\subsection{Алгоритм поиска в индексе}\label{search}

Для поиска расположений файлов, в которых содержатся ключи, удовлетворяющие предикату запроса, в первую очередь, необходимо прочитать метаданные индекса, в которых содержится информация о существующих сегментах индекса, чтобы получить список сегментов $S$.

Поиск расположений для точечного запроса схож в алгоритмом поиска, используемом для структуры данные {<<Sieve>>} \cite{Sieve}.

\textbf{Алгоритм поиска расположений для точечного запроса по ключу $k$:}
\begin{enumerate}
    \item Список сегментов является отсортированным, соответственно за время $O(logN)$, где $N$ - количество сегментов в индексе, возможно найти сегмент $s$, который содержит информацию о ключе $k$, используя бинарный поиск по списку сегментов.
    \item Сегмент $s$, содержащий информацию о ключе $k$, загружается из хранилища данных.
    \item В загруженном сегменте $s$ в массиве блоков необходимо найти блок, который содержит расположение файлов $loc$, в которых присутствует ключ $k$, сделать это возможно за время $O(1)$ вычислив номер соответствующего блока: $b_{i} = \frac{k - s_{min}}{b_{size}}$.
    \item Список расположений из полученного блока $loc = b_{i}.L$ --- есть множество расположений, которые необходимо включить в рассмотрение для выполнения запроса.
\end{enumerate}

Далее разработаем алгоритм обработки интервального запроса.

\textbf{Алгоритм поиска расположений для интервального запроса по ключам из интервала $[l, r]$:}
\begin{enumerate}
    \item За время $O(1)$ найти блок, содержащий информацию о ключе $l$, аналогично алгоритму поиска расположений для точечного запроса.
    \item Далее последовательно считывать следующие за ним блоки, пока для очередного блока выполняется $r \leq b_{max}$.
    \item Перейти к чтению блоков из следующего сегмента (шаг 2), предыдущий сегмент может быть выгружен из памяти.
\end{enumerate}
