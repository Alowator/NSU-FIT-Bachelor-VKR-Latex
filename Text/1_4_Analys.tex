\subsection{Анализ существующих решений}\label{indexes}

Для создания структуры данных, которая может помочь решить задачу пропуска нерелевантных файлов для интервальных запросов, необходимо ознакомиться с существующими решениями в платформах для доступа к данным. Существует множество специфичных индексов, решающих разные задачи, однако одно из определенных нами требований --- возможность индексировать разные типы данных, таким образом для рассмотрения не подходят индексы работающие, например, только со строковыми типами. Более того, для решения задачи необходима поддержка интервальных предикатов. В существующих платформах для доступа к данным таких решений несколько, это: упрощенные сводки, точные индексы и фильтры Блума \cite{Extensible_data_skipping}. Далее рассмотрим каждую из структур подробнее.

\subsubsection{Упрощенные сводки}\label{column_stats}

В параграфе \ref{subsec:definition} уже была рассмотрена структура данных {<<Упрощенные сводки>>}. Более того, было доказано (Теорема \ref{theorema}), что такая структура данных является оптимальной для интервальных неограниченных запросов. Однако для интервальных ограниченных запросов использование такой структуры данных может приводить к чтение нерелевантных файлов. Например, каждый файл с данными может содержать удаленные друг от друга значения --- отметки времени только за январь и только за декабрь определенного года, но при этом не содержать значений внутри этого диапазона. Тогда для точечных запросов, например, за конкретный день июля, или для запросов, нацеленных на извлечение данных за ограниченный с двух сторон период, например, с июня по август того же года, такой подход приведет к необходимости чтения файлов, которые не содержат нужной информации.

Упрощенные сводки --- это тривиальная структура, которая не требует детального описания. Эти структуры просты в использовании и требуют минимальных затрат на хранение. Более того, размер такой структуры не зависит от объёма данных, который она описывает, что позволяет оценить затраты по памяти на хранение таких структур для каждого файла в O(1), так как для одного файла такая структура содержит всего 2 значения --- минимальное и максимальное значение атрибута. Однако их эффективность такой структуры зависит от конкретного набора данных внутри индексируемого файла.

В действительности упрощенные сводки оказываются эффективными для упорядоченных атрибутов, которые не содержат пропуском, например, целочисленные первичные ключи. Это такие сценарии использования, где индексируемый атрибут в файле не содержит пропусков.

В дальнейшем в данной работе для краткости будем использовать следующее определение для индексируемых значений:
\begin{definition}
    \textbf{Ключ} --- конкретное значение индексируемого атрибута таблицы, то есть значение атрибута, по которому построен индекс для отсеивания нерелевантных файлов при заданном интервальном запросе, в котором интервал задан по значениям (ключам) этого же атрибута.
\end{definition}


\subsubsection{Точные индексы} 

Точные индексы в системах для доступа к данным отображают значение атрибута каждой отдельной записи на её расположение \cite{Hudi_RLI}. Используя такое определение можно сформировать семейство точных индексов, где каждая запись в индексе соответствует одной записи в таблице \cite{Tree_Data_Structures_and_Efficient_Indexing_Techniques}.

Основная проблема таких индексов заключается в том, что объём индекса становится соразмерным с объёмом пользовательских данных, их сложность по памяти есть O(N) \cite{Tree_Data_Structures_and_Efficient_Indexing_Techniques}. Согласно документации Hudi, размер одной записи в точном индексе составляет приблизительно 50 байт \cite{Hudi_RLI}. Для оценки размера индекса относительно размера данных предположим, что размер одной записи составляет 100 КБ \cite{Hudi_RLI}. В таком случае для таблицы объёмом 10 ТБ размер индекса достигнет 5 ГБ, что приводит к необходимости чтения всего индекса размером 5 ГБ при любом запросе. Более того, индексируемый атрибут (ключ) может иметь значительно больший размер, чем принято в данных расчетах, например, это может быть строковый тип данных.

Точные индексы отображают значение \textbf{каждого ключа}, а значит, и индекс будет иметь размер не меньше, чем размер индексируемого атрибута. Таким образом, размер индекса в значительной степени зависит от размера индексируемого атрибута.

В действительности, попытка оценить итоговый размер индекса относительно всего набора данных, содержащего помимо индексируемого атрибута множество других атрибутов, не является объективной. Достаточно увеличить количество атрибутов в схеме таблицы, и размер индекса станет меньше относительно размера всей таблицы, как итог, такая оценка не отражает реальный размер индекса, поэтому в дальнейшем в данной работе будем производить оценку размера индекса относительно размера индексируемого атрибута по следующей формуле:

\begin{equation}\label{eq:size_per_key}
    \textrm{размер индекса на ключ} = \frac{\textrm{размер индекса в байтах}}{\textrm{кол-во ключей}}
\end{equation}

Таким образом, итоговый размер точного индекса всегда не меньше размера индексируемого атрибута, а в действительности его размер будет больше, так как помимо самого ключа, необходимо хранить множество расположений данного ключа. Данные индексы созданы для решения другой задачи --- точечного обновления записей \cite{Hudi_RLI}.

\subsubsection{Фильтр Блума} 

Фильтр Блума состоит из битового массива длиной $m$ бит и набора $k$ различных хеш-функций $h$, которые генерируют значения от $0$ до $m−1$, соответствующие позициям битов в массиве. В начальном состоянии, когда структура данных не содержит элементов, все биты массива установлены в ноль \cite{Bloom_Filter}.

Фильтр Блума реализует реализует две основные операции: добавлением элемента в множество и проверка принадлежности элемента множеству. Для добавления элемента $e$ необходимо установить в единицу биты на позициях $h_1(e), \dots, h_k(e)$. Для проверки принадлежности элемента достаточно вычислить значения хеш-функций для этого элемента и убедиться, что все соответствующие биты установлены в единицу, что дает ответ {<<возможно>>}, в случае, если дан ответ {<<возможно>>}, когда в действительности элемент не принадлежит множеству, такой ответ является \textbf{ложноположительным}. Если хотя бы один бит не установлен в единицу, это означает, что элемент не принадлежит множеству — ответ "нет" \cite{Bloom_Filter,Role_of_bloom_filter_in_big_data}.

Основным преимуществом фильтра Блума является его простота реализации, что и обусловило его широкую популярность, фильтры Блума используются не только в контексте больших данных, но и в задачах дедупликации данных, в сетевых технологиях, файловых системах и других областях \cite{Role_of_bloom_filter_in_big_data}. Несмотря на простоту, фильтр Блума остаётся очень компактной структурой данных. Его размер значительно меньше индексируемого набора данных. Например, для количества элементов $n = 1.000.000$ и вероятности ложноположительного ответа $p = 0.01$ при $k = 7$ размер индекса на ключ (\ref{eq:size_per_key}) будет равен примерно 10 бит \cite{Bloom_Filter}.

Недостатком использования фильтра Блума для отсеивания нерелевантных файлов является необходимость прочитать либо все фильтры, если каждому файлу данных соответствует отдельный фильтр, либо прочитать весь фильтр, если он ассоциирован со всеми файлами данных, содержащими индексируемый атрибут, это следует из описания операций добавления элемента в множество и проверки принадлежности элемента множеству. Более, стандартная реализация фильтра Блума не предполагает возможность удаления элемента из индекса, однако поддержка такой операции необходима.

Однако наиболее значимым недостатком фильтра Блума является его неспособность обрабатывать интервальные запросы. Фильтр Блума эффективно отвечает на запросы о принадлежности одного ключа множеству, то есть на точечные запросы. Однако при необходимости проверить принадлежность каждого ключа из заданного интервала, временная сложность операции составит $O(N \cdot M)$, где $N$ --- количество проверяемых фильтров, а $M$ --- количество ключей в интервале. 

Таким образом, фильтр Блума не подходят для решения задач отсеивания нерелевантных файлов из-за необходимости чтения всей структуры данных и большой асимптотической сложности обработки интервальных запросов.


\newpage
\section*{Выводы}
\addcontentsline{toc}{section}{Выводы}

В данной главе дано определение предметной области --- это индексация и фильтрация нерелевантных файлов с данными для их более быстрого чтения в распределенных базах данных при выполнении интервальных запросов. Также описано устройство систем для доступа к данным, из чего сформирован ряд требований к структуре данных, призванной решить задачу пропуска нерелевантных файлов для интервальных запросов. В параграфе \ref{indexes} были исследованы существующие фильтры для пропуска файлов, данные в которых не удовлетворяют предикату интервального запроса.

Существующие решения для пропуска нерелевантных файлов не применимы в рамках интервальных запросов ввиду их большого размера или большой асимптотической сложности для ответа на интервальные запросы.
