\subsection{Анализ существующих решений}\label{subsec:indexes}

Для создания структуры данных, которая может помочь решить задачу пропуска нерелевантных файлов для интервальных запросов, необходимо ознакомиться с существующими решениями в платформах для доступа к данным. Существует множество специфичных индексов, решающих разные задачи, однако одно из определенных нами требований --- возможность индексировать разные типы данных, таким образом для рассмотрения не подходят индексы работающие, например, только со строковыми типами. Более того, для решения задачи необходима поддержка интервальных предикатов. В существующих платформах для доступа к данным таких решений несколько, это: упрощенные сводки, точные индексы и фильтры Блума~\cite{Extensible_data_skipping}. Далее рассмотрим каждую из структур подробнее.

\subsubsection{Упрощенные сводки}\label{subsubsec:column_stats}

В разделе \ref{subsec:definition} уже была рассмотрена структура данных {<<Упрощенные сводки>>}. Более того, было доказано (Теорема \ref{theorema}), что такая структура данных является оптимальной для интервальных неограниченных запросов. Однако для интервальных ограниченных запросов использование такой структуры данных может приводить к чтению нерелевантных файлов. Например, каждый файл с данными может содержать удаленные друг от друга значения --- отметки времени только за январь и только за декабрь определенного года, но при этом не содержать значений внутри этого диапазона. Тогда для точечных запросов, например, за конкретный день июля, или для запросов, нацеленных на извлечение данных за ограниченный с двух сторон период, например, с июня по август того же года, такой подход приведет к необходимости чтения файлов, которые не содержат нужной информации.

Упрощенные сводки --- это тривиальная структура, которая не требует детального описания. Эти структуры просты в использовании и требуют минимальных затрат на хранение. Более того, размер такой структуры не зависит от объема данных, который она описывает, что позволяет оценить затраты по памяти на хранение таких структур для каждого файла в O(1), так как для одного файла такая структура содержит всего 2 значения --- минимальное и максимальное значение атрибута. Однако эффективность такой структуры зависит от конкретного набора данных внутри индексируемого файла.

В действительности упрощенные сводки оказываются эффективными для упорядоченных атрибутов, которые не содержат пропусков, например, упорядоченные целочисленные первичные ключи.

В дальнейшем в данной работе для краткости будем использовать следующее определение для индексируемых значений:
\begin{definition}\label{def:key}
    \textbf{Ключ} --- конкретное значение индексируемого атрибута таблицы, то есть значение атрибута, по которому построен индекс для отсеивания нерелевантных файлов при заданном интервальном запросе, в котором интервал задан по значениям (ключам) этого же атрибута.
\end{definition}


\subsubsection{Точные индексы} 

Точные индексы в системах для доступа к данным отображают значение атрибута каждой отдельной записи на ее расположение~\cite{Hudi_RLI}. Используя такое определение можно сформировать семейство точных индексов, где каждая запись в индексе соответствует одной записи в таблице~\cite{Tree_Data_Structures_and_Efficient_Indexing_Techniques}.

Основная проблема таких индексов заключается в том, что размер индекса становится соразмерен пользовательским данным, их сложность по памяти --- O(N), где $N$ - количество записей в пользовательской таблице~\cite{Tree_Data_Structures_and_Efficient_Indexing_Techniques}. Согласно документации Hudi, размер одной записи в точном индексе составляет приблизительно 50 байт~\cite{Hudi_RLI}. Для оценки размера индекса относительно размера данных предположим, что размер одной записи составляет 100 КБ~\cite{Hudi_RLI}. В таком случае для таблицы объемом 10 ТБ размер индекса достигнет 5 ГБ, что приводит к необходимости чтения всего индекса размером 5 ГБ при любом запросе. Более того, индексируемый атрибут (ключ) может иметь значительно больший размер, чем принято в данных расчетах, например, это может быть строковый тип данных.

Точные индексы отображают значение \textbf{каждого ключа}, а значит, и индекс будет иметь размер не меньше, чем размер индексируемого атрибута. Таким образом, размер индекса в значительной степени зависит от количества записей в пользовательской таблице.

В действительности, попытка оценить итоговый размер индекса относительно всего набора данных, содержащего помимо индексируемого атрибута множество других атрибутов, не является объективной. Достаточно увеличить количество атрибутов в схеме таблицы, и размер индекса станет меньше относительно размера всей таблицы, как итог, такая оценка не отражает реальный размер индекса, поэтому в дальнейшем в данной работе будем производить оценку размера индекса относительно размера индексируемого атрибута по следующей формуле:

\begin{equation}\label{eq:size_per_key}
    \textrm{размер индекса на ключ} = \frac{\textrm{размер индекса в байтах}}{\textrm{кол-во ключей}}
\end{equation}

Таким образом, итоговый размер точного индекса всегда не меньше размера индексируемого атрибута, а в действительности его размер будет больше, так как помимо самого ключа, необходимо хранить множество расположений (Определение \ref{def:location}), в которых содержится данный ключ. Данные индексы созданы для решения другой задачи --- точечного обновления записей~\cite{Hudi_RLI}.

\subsubsection{Фильтр Блума} 

Фильтр Блума~\cite{Bloom_Filter} состоит из битового массива длиной $m$ бит и набора $k$ независимых хеш-функций $h_1, \dots, h_k$, каждая из которых генерирует значения из ${0, \dots, m-1}$, соответствующие позициям битов в массиве. В начальном состоянии, когда структура данных не содержит элементов, все биты равны нулю.

Фильтр Блума реализует реализует две основные операции: добавлением элемента в множество и проверка принадлежности элемента множеству. Для добавления элемента $e$ необходимо установить в единицу биты на позициях $h_1(e), \dots, h_k(e)$. Для проверки принадлежности элемента достаточно вычислить значения хеш-функций для этого элемента и убедиться, что все соответствующие биты равны единицам, что дает ответ {<<возможно>>}, в случае, если дан ответ {<<возможно>>}, когда в действительности элемент не принадлежит множеству, такой ответ является \textbf{ложноположительным}. Если хотя бы один бит не равен единице, это означает, что элемент не принадлежит множеству — ответ "нет".

Основным преимуществом фильтра Блума является его точность и простота реализации, что и обусловило его широкую популярность, фильтры Блума используются не только в контексте больших данных, но и в задачах дедупликации данных, в задачах передачи данных по сети, файловых системах и других областях~\cite{Role_of_bloom_filter_in_big_data}. Несмотря на простоту, фильтр Блума остается очень компактной структурой данных. Не смотря на то, что число бит $m$, использованных в фильтре Блума, в несколько раз больше чем число ключей в индексируемом наборе, размер фильтра Блума сильно меньше, чем длина записи всех ключей из набор,. Например, для количества элементов $n = 1.000.000$,  и вероятности ложноположительного ответа $p = 0.01$, оптимальным значением количества функций будет $k = 7$, а размер индекса на ключ (\ref{eq:size_per_key}) будет равен примерно 3 битам, при размере ключа 32 бита.~\cite{Bloom_Filter}.

Недостатком использования фильтра Блума для отсеивания нерелевантных файлов является необходимость прочитать либо все фильтры, если каждому файлу данных соответствует отдельный фильтр, либо прочитать один большой фильтр, ассоциированный со всеми файлами данных, содержащими индексируемый атрибут. Более того, стандартная реализация фильтра Блума не предполагает возможность удаления элемента из индекса, однако поддержка такой операции необходима.

Однако наиболее значимым недостатком фильтра Блума является его неспособность обрабатывать интервальные запросы. Фильтр Блума эффективно отвечает на запросы о принадлежности одного ключа множеству, то есть на точечные запросы. Однако при необходимости проверить принадлежность каждого ключа из заданного интервала, временная сложность операции составит $O(N \cdot M)$, где $N$ --- количество проверяемых фильтров, а $M$ --- количество ключей в интервале. 

Стоит отметить, что существуют модификации фильтра блума, которые поддерживают операции удаления~\cite{Counting_bloom_filter} и интервальные запросы~\cite{Count_min_sketch}, однако существующие реализации фильтра Блума в системах доступа к данным не подходят для решения задач отсеивания нерелевантных файлов из-за необходимости чтения всей структуры данных и большой временной сложности обработки интервальных запросов.


\newpage
\section*{Выводы}
\addcontentsline{toc}{section}{Выводы}

В данной главе дано определение предметной области --- это индексация и фильтрация нерелевантных файлов с данными для их более быстрого чтения в распределенных базах данных при выполнении интервальных запросов. Также описано устройство систем для доступа к данным, из чего сформирован ряд требований к структуре данных, призванной решить задачу фильтрации нерелевантных файлов для интервальных запросов. В разделе \ref{subsec:indexes} были исследованы существующие в системах доступа к данным фильтры для пропуска файлов, данные в которых не удовлетворяют предикату интервального запроса.

Существующие решения для фильтрации нерелевантных файлов не применимы для ускорения выполнения интервальных запросов ввиду их большого размера или большой временной сложности для ответа на интервальные запросы.
