\subsection{Алгоритм построения индекса}\label{build}

Алгоритм построения состоит из двух этапов: сортировка ключей и построение сегментов индекса.

Первый этап является вычислительно самым трудоемким, так как одно из ограничений в платформах для обработки больших данных --- ограниченный размер оперативной памяти вычислительных узлов (\ref{subsec:requirements}). Для того чтобы построить функцию $R$, необходимо отсортировать весь набор ключей для того чтобы отслеживать изменение значения функции $R$. Так как размер всего множества ключей $K$ может не уместиться в оперативную память одного вычислительного узла и даже всех вычислительных узлов вместе взятых. Однако данную операцию возможно реализовать с использованием системы для обработки данных (\ref{subsec:definition}), то есть производить данные вычисления, используя вычислительные ресурсы всего кластера, так как система для обработки данных имеют возможность работы выполнения таких запросов как сортировка и агрегация данных, которые не умещаются в оперативную память, при этом может задействоваться локальная файловая система узлов кластера, при недостатке оперативной памяти вычислительных узлов~\cite{Impact_of_memory_size_on_bigdata}. В данной работе системой для обработки данных является Apache Spark.

Структура данных {<<Sieve>>} имеет реализованный алгоритм построения индекса, однако его реализация не рассматривает ограничение размера оперативной памяти для построения сегментов. Реализуем модифицированную версию данного алгоритма.

Сперва необходимо выполнить первый этап и получить набор данных $df$, содержащий отсортированные и агрегированные данные. Второй этап заключается в формировании сегментов и сохранению их в хранилище данных, получая из вычислительного кластера каждый следующий ключ вместе с множеством его расположений один за одним и отслеживая значение ошибки для текущего сегмента. Данная операция производится на одном вычислительном узле, так как для формирования сегментов индекса необходимо пройти все множество ключей по возрастанию один раз. Формирование очередного сегмента заканчивается при достижении им определенного размера (так как объем оперативной памяти вычислительного узла ограничен) или при достижении порога ошибки, согласно алгоритму для выделения сегментов. После формирования очередного сегмента, необходимо вычислить размер блоков (\ref{eq:partition_size}) внутри него и сформировать эти блоки, используя алгоритм формирования блоков (представлен далее в этом разделе), после чего сегмент сохраняется в хранилище данных и может быть выгружен из оперативной памяти. Таким образом возможно преодолеть ограничение оперативной памяти вычислительного узла и невозможность выполнить сегментацию в системе обработки данных. $indexColumn$ --- индексируемый атрибут.

\textbf{Алгоритм построения Сито-индекса:}
\begin{enumerate}
\item $df = select(indexColumn, loc).sort(indexColumn)\\.groupBy(indexColumn).add(collect(loc))$
\item Создается пустой список $segments$ для хранения метаданных сегментов индекса.
\item Итерация по набору данных из отсортированных ключей, для очередного ключа $k$ и его множества расположений $loc$:
    \begin{enumerate}
    \item Если текущий сегмент $s$ не содержит ключей, то в него добавляется $k$ и множество расположений $loc$.
    \item Если значение $sl$ достигло определенной ошибки (шаг 2 алгоритма для выделения сегментов), производится формирование блоков для этого сегмента и он сохраняется в файловое хранилище, после чего может быть выгружен из памяти.
    \item Иначе $k$ вместе с его расположениями $loc$ сохраняется в сегменте $s$ для дальнейшего формирования блоков.
    \end{enumerate}
\item Если последний строящийся $s$ содержит ключи, производится формирование блоков для этого сегмента и он сохраняется в файловое хранилище.
\item В файловое хранилище сохраняются метаданные индекса, в виде списка доступных сегментов $S$, каждый элемент такого списка $S_i$ содержит лишь значения $s_{min}$ и $s_{max}$. Сегменты сохраняются упорядоченно $S_{(i)max} < S_{(i+1)min}$.
\end{enumerate}

\textbf{Алгоритм формирования блоков:}
\begin{enumerate}
    \item Вычислить размер $b_{size}$ (\ref{eq:partition_size}).
    \item Вычислить кол-во блоков для данного сегмента $b_{count} = s_{size} / b_{size}$.
    \item Сформировать массив блоков $B$ размеров $b_{count}$.
    \item Для каждого ключа $k$ и его множества расположений $loc$: 
        \begin{enumerate}
        \item Вычислить $i = (k - s_{min}) / b_{size}$.
        \item Добавить в блок $B_{i}$ все расположения $loc$, обновить счетчики расположений $B_{i}.L$ для каждого расположения из $loc$.
        \end{enumerate}
    \item Сохранить массив блоков $B$, остальная информация может быть выгружена из памяти.
    \item Установить значение предела дополнительных ложноположительных ответов для сегмента $s.E = e \cdot b_{count}$
\end{enumerate}

Инициировать создание Сито-индекса возможно с помощью SQL-запроса, этот процесс подробно описан в руководстве пользователя (Приложение А) и описании программы (Приложение Б).