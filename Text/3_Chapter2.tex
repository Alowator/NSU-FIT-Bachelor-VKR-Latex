\section{Внедрение сито-индекса в систему доступа к данным}
Теоретическое определение Сито-индекса разработано с учетом всех ограничений предметной области, однако для его внедрения в конкретную платформу управления данными, такую как Apache Hudi, необходимо детально формализовать все операции по обновлению индекса и специфицировать алгоритм его построения в распределенной среде.


\subsection{Построение индекса}

Задача построения индекса формулируется следующим образом: для заданного индексируемого атрибута требуется создать и реализовать персистентное хранение индекса в таблице. Важно отметить, что в общем случае индексируемый атрибут не умещается в оперативной памяти вычислительного узла.

При построении индекса работаем с отношением, содержащим два атрибута: индексируемый атрибут (ключ) и расположение файла данных, содержащего данный ключ. Уникальность ключей в общем случае не гарантируется, что делает необходимым сортировку данного набора для построения кумулятивной распределительной функции.

Процесс построения индекса различается для новых и существующих таблиц. Для новой таблицы построение индекса начинается с декларации его использования, после чего происходит обновление индекса согласно пункту 2.4.

Для существующих таблиц необходимо, чтобы набор ключей был отсортирован, причем уникальность каждого ключа не гарантируется. Простейшее решение заключается в применении любого метода сортировки, при этом стабильность сортировки не является обязательной. Сложность задачи построения индекса для существующей таблицы возрастает из-за необходимости сортировать и агрегировать большой объем данных для определения расположения каждого ключа. Проблема вытекает из необходимости создания упорядоченного массива ключей, на основе которого будет сформирована кумулятивная распределительная функция.

Построение индекса для существующей таблицы представляет собой более общий случай. Основная задача заключается в формировании упорядоченного массива ключей для создания кумулятивной распределительной функции.

Для решения этой задачи применим возможности распределенного движка Spark, используемого в Hudi. С его помощью осуществляется сортировка ключей и агрегация, что позволяет получить набор расположений для каждого уникального ключа. Этот метод является оптимальным, так как задача сортировки большого объема данных, который не умещается в оперативной или даже постоянной памяти компьютера, имеет известные решения, но остается нетривиальной.

После сортировки ключей достаточно в однопоточном режиме пройтись по каждому из них, поддерживая текущее кумулятивное значение функции для определения момента изменения тренда данных и необходимости формирования нового сегмента.

Существует вероятность, что весь набор данных будет иметь общий тренд, и с точки зрения подхода Sieve целесообразно создать один большой сегмент. Однако это невозможно из-за ограничений оперативной памяти вычислительного узла, что требует прекращения генерации сегмента при достижении его определенного размера. Экспериментально было установлено, что размер сегмента не должен превышать 3 миллиона записей при выделенных 2 ГБ оперативной памяти на вычислительный узел. Далее следует определить оптимальный размер блока, при котором вероятность ошибки окажется ниже установленного порога. Каждый сегмент делится на блоки, в которых сохраняется информация о местоположениях, ассоциированных с данным интервалом ключей. После завершения этих операций сегмент сериализуется на файловую систему.

Таким образом, благодаря возможностям распределенного движка и особенностям однопроходного алгоритма сегментации данных, можно эффективно построить Сито-индекс для объемного набора данных, который не умещается в память компьютера.

\subsection{Поиск в индексе}

Задача поиска нужных блоков в Сито-индексе для отфильтровывания нерелевантных данных аналогична поиску блоков данных в B-дереве. Основное различие между обработкой интервального запроса и точечным запросом заключается в следующем: для точечного запроса требуется найти и прочитать один блок, тогда как для интервального запроса необходимо определить один начальный блок, содержащий ключ из предиката. Например, для предиката a>5 необходимо найти блок, содержащий ключ 5, и последовательно прочитать все блоки, в которых находятся ключи с большими значениями. Эта операция эффективна, поскольку блоки расположены последовательно, что исключает необходимость поиска отдельных блоков в структуре индекса.

Сегменты индекса маркируются минимальным и максимальным значениями ключей, содержащихся в каждом сегменте, что позволяет определить соответствующий сегмент для заданного предиката за время O(logN) с использованием алгоритма бинарного поиска.

Номер соответствующего блока внутри сегмента может быть вычислен по формуле $(key − min_key)  block_size$, где деление выполняется как 
целочисленное, key  это искомый ключ, minkey  минимальный ключ в сегменте, а blocksize известный размер блока для текущего сегмента.

\subsection{Обновление индекса}

Существуют три типа операций обновления индекса: добавление записи, ключевой атрибут которой отсутствует в индексе; удаление записи, ключевой атрибут которой присутствует в индексе; и обновление существующей записи, когда ключевой атрибут уже занесен в индекс. Кроме того, осуществляется операция удаления записи из индекса.

Для эффективного обновления индекса целесообразно использовать подход Merge-On-Read, поскольку обновление сегмента при каждой операции вставки является ресурсоемким.

С этой точки зрения, индекс должен быть синхронизирован с текущим состоянием таблицы. Для достижения этой синхронизации необходимо применять те же механизмы управления параллельными версиями (MVCC), которые используются для управления таблицей.

После накопления множества изменений (дельт) в индексе, необходимо провести процесс компактизации индекса в синхронизации с компактизацией индексируемой таблицы. Для поддержки фильтрации нерелевантных данных при выполнении исторических запросов требуется версионирование не только данных, но и индекса. При компактизации таблицы старая версия сегмента должна быть помечена тем же временным штампом, что и старая версия данных, после чего обновленный сегмент записывается в файловую систему.

2.3.1. Добавление записи
Процесс добавления записи, ключевой атрибут которой отсутствует в индексе, включает добавление в соответствующую группу файлов, ассоциированную с сегментом дельта-файла. Дельта-файл содержит информацию о добавленных ключах и о расположении соответствующих файлов данных на файловой системе.

2.3.2. Удаление записи
Большинство теоретических описаний подходов, используемых при создании Сито-индекса, не включает описание операции удаления ключа из индекса, хотя поддержка данной операции необходима. Подход к реализации этой операции аналогичен процессу добавления записи: необходимо записать в дельту, что ключ k был удален из индекса. В процессе компактизации следует удалить из индекса запись с указанием местоположения. Однако этот подход может быть некорректен при удалении ключа из блока, если местоположение, ассоциированное с удаленным ключом, соответствует также другим ключам, которые не были удалены. Это может привести к ложноотрицательным результатам, когда записи, соответствующие данному местоположению, окажутся утраченными.

Процесс удаления записи, ключевой атрибут которой присутствует в индексе, реализуется аналогично процессу добавления записи. Необходимо определить файловую группу, ассоциированную с сегментом, внести изменения и записать в дельта-файл информацию о удаленных ключах и их расположениях. Для предотвращения ложноотрицательных результатов в списке местоположений каждого блока следует хранить не только расположение файлов данных, но и количество ключей, которым соответствует данное расположение. Таким образом, удаление местоположения из подсегмента заключается в уменьшении второго элемента данной пары на одну единицу, если значение больше единицы, и в удалении пары из списка, если это значение равно единице. Аналогичные изменения необходимы также в процедуре добавления записей. Этот подход, называемый подсчетом (англ. counting), является общепринятым [16].

2.3.3. Обновление записи
Обновление записи в системе Hudi представляет собой более сложную концепцию по сравнению с традиционными системами управления базами данных (СУБД). В отличие от стандартных СУБД, Hudi поддерживает выполнение исторических запросов. В общем случае, при обновлении набора записей сохраняется предыдущий актуальный файл данных, а также создается новый файл данных, который отражает актуальное состояние данных после обновления. Таким образом, местоположение данных не изменяется с появлением нового файла данных, который соответствует последующему моменту времени на временной шкале. Для операций обновления записи по уже существующему ключу обновление индекса не требуется.

\subsection{Результат внедрения}
В данном разделе представлены результаты сравнения производительности индекса Sieve и полного сканирования таблицы при выполнении точечных и интервальных запросов с различной селективностью данных. Набор данных был сгенерирован с использованием бенчмарка TPC-H, причем запросы выполнялись на таблице «lineitem» по первичному ключу.

В рамках тестирования индекс был построен на двух наборах данных: первые 20 миллионов строк (набор 1) и первые 600 миллионов строк (набор 2) из таблицы "lineitem". Выбор данных объемов данных был обусловлен возможностями Spark в режиме standalone, где использовался один вычислительный узел с объемом выделенной памяти 2 ГБ. Это позволило проверить возможность индексации таблицы из 20 миллионов записей с полной загрузкой всех значений атрибута в память, в то время как загрузка 600 миллионов записей в память оказалась невозможной.

Размер индекса для первого набора данных составил 11 МБ при общем размере индексируемого атрибута 160 МБ, а для второго — 300 МБ при общем размере индексируемого атрибута 5 ГБ. В обоих случаях средний размер блока составил p = 32. При этом размер индекса составил всего около 6 от исходного размера индексируемого атрибута. Учитывая, что в реальных сценариях использования таблицы могут содержать десятки атрибутов, размер индекса будет составлять лишь десятые и сотые доли процента от общего размера таблицы.
Далее представлены результаты тестирования в виде гистограмм, где по оси ординат отложено время выполнения запроса в секундах.

\fbox{картинки-графики}

\section*{Выводы}
\addcontentsline{toc}{section}{Выводы}

Следует подчеркнуть потенциал внедрения структуры данных Сито-индекс в современные платформы озер данных, такие как Apache Hudi, Iceberg и DeltaLake. Принципы работы с данными в них имеют много общего, что делает возможным применение Сито-индекса также и в других платформах.

Особенностью Сито-индекса является его легковесность, позволяющая полностью загружать его в оперативную память. Это становится возможным благодаря тому, что размер индекса составляет всего десятые доли процента от общего объема данных. Такая эффективность открывает перспективы использования Сито-индекса не только в платформах озер данных, но и в SQL-движках, предназначенных для обработки больших данных, например, в Apache Presto.

Индексация данных в рамках платформы Apache Hudi показала, что даже при работе с большими объемами данных (до 600 миллионов строк) возможно эффективное построение индекса, что подтверждает его применимость в условиях ограниченной памяти.
