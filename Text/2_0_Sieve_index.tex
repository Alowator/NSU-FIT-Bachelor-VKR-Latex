\section{Сито-индекс и его внедрение в систему доступа к данным}

Для решения задачи пропуска нерелевантных файлов для интервальных запросов необходимо разработать структуру данных, которая будет одновременно иметь небольшой размер относительно размера индексируемого атрибута (см. раздел \ref{subsec:requirements}), то есть иметь размер индекса на ключ (\ref{eq:size_per_key}) такой, при котором накладные расходы на хранение и доступ к индексу не приведут к тому, что выполнение запроса с использованием индекса будет медленнее выполнения запроса без использования этого же индекса.

В данной работе для системы доступа к данным Apache Hudi была разработана и внедрена структура данных, названная \textbf{Сито-индекс}. Сито-индекс является модификацией структуры данных Sieve~\cite{Sieve}, адаптированной для индексации больших наборов данных: часть построения структуры данных проводится распределенно с использованием системы для обработки данных Apache Spark; добавлена поддержка операций обновления индекса (добавление и удаление записей), реализованное с учетом стратегий управления данными {<<копирование при записи>>} и {<<слияние при чтении>>}; добавлена поддержка ответов на интервальные запросы. 

Данная глава организована следующим образом. В разделе~\ref{subsec:implementation} приводятся необходимые идеи разбиения индексируемых данных из работы~\cite{Sieve} о структуре данных Sieve, в разделе~\ref{subsec:build} описан алгоритм построения Сито-индекса, в разделе~\ref{subsec:search} описан алгоритм поиска в Сито-индексе, в разделе~\ref{subsec:update} описан алгоритм обновления Сито-индекса, а в разделе~\ref{subsec:results} представлены численные результаты экспериментов.

\subsection{Идея Сито-индекса}\label{subsec:implementation}

Стоит обратить внимание, что в постановке задачи (см. раздел  \ref{subsec:definition}) данные в каждом файле имеют некоторую закономерность, например, еще раз рассмотрим случай, когда упрощенные сводки (см. раздел \ref{subsubsec:column_stats}) дают ложноположительный ответ: файл может содержать в качестве значений отметки времени за только январь и только за декабрь определенного года.
Тогда для запросов, нацеленных на извлечение данных за определенные периоды, например, с июня по август того же года, упрощенные сводки дадут ложноположительный ответ для данного файла. Отсюда следует вывод, что данные за январь и декабрь текущего года расположены именно в этом файле (и, возможно, в каких-то других), а данные за период с февраля по ноябрь точно содержатся в других файлах.

Существуют эвристические подходы для построения индексов, которые используют такие закономерности в данных.
Например, подход Sieve~\cite{Sieve}, который основан на наблюдении, что \textbf{близкие по значению ключи часто находятся в одних и тех же файлах}. Именно данное предположение отражают те случаи, когда упрощенные сводки дают ложноположительные ответы, так как упрощенные сводки никак не учитывают реальное расположение данных внутри каждого файла.

Напомним, что под расположением в данной работе имеется ввиду путь к файлу и его идентификатор (Определение \ref{def:location}). \textbf{Множество расположений} ключа k --- набор расположений (файлов), в которых присутствует значение k.

Sieve предлагает следующую модель для определения закономерности в распределении данных:

Пусть $k$ --- ключ (Определение \ref{def:key}) из множества ключей, представимых в виде целого числа (целые числа, даты, отметки времени) $K$, тогда введем функцию R:
\begin{equation}\label{R_CDF}
R(k) = 
\begin{cases} 
    R(k - 1), & \text{если множества расположений $k$ и $k - 1$ равны}, \\
    R(k - 1) + 1, & \text{в остальных случаях}.
\end{cases}
\end{equation}

Значение функции $R$ в точке $k$ --- есть общее количество раз, когда множество расположений изменилось для ключей $k$ и $k - 1$.
Далее для построения модели производится линеаризация отдельных сегментов данной функции.
Таким образом каждый сегмент отражает некоторую закономерность в распределении ключей между файлами.
Например, если линеаризованный участок (сегмент) параллелен оси абсцисс, это значит, что множество расположений ключей в данном сегменте не менялось, соответственно, для того, чтобы сохранить информацию о данном сегменте, можно использовать меньше памяти: достаточно сохранить минимальное и максимальное значений ключей для данного сегмента и множество расположений, в которых ключи из этого промежутка расположены, и напротив, если тангенс угла линеаризованного участка равен единице, это значит, что расположения ключей различаются для каждых соседних ключей, то есть этот участок необходимо разделить на более мелкие блоки, каждый из которых должен содержать информацию о минимальном и максимальном значении ключей каждого блока и множество расположений этих ключей, для того чтобы снизить вероятность ложноположительных ответов для этого сегмента.

Введем следующие обозначения:
$e$ - допустимая ошибка сегмента (задается пользователем), $s$ --- сегмент (множество ключей из интервала $[s_{min}, s_{max}]$), $s_{min}, s_{max}$ --- соответственно минимальное и максимальное значения ключа в сегменте, $s_{size} = s_{max} - s_{min}$, $s.E$ --- заданное ограничение на число дополнительных ложноположительных ответов для сегмента, $b$ --- блок (часть сегмента, множество ключей из интервала $[b_{min}, b_{max}]$, где $s_{min} \leq b_{min} \leq b_{max} \leq s_{max}$), $b_{min}, b_{max}$ --- соответственно минимальное и максимальное значение ключа в блоке.

Существует множество вариантов линеаризации сегментов функции R, однако модель Sieve~\cite{Sieve} предлагает следующий алгоритм, этот алгоритм будет являться вспомогательным для реализации алгоритма построения Сито-индекса (см. раздел \ref{subsec:build}).

\textbf{Алгоритм для выделения сегментов:}
\begin{enumerate}
\item $s_{min}$ --- значение, получаемое в процессе алгоритма построения индекса (см. раздел \ref{subsec:build}.)
\item $slLow = 0, slHigh = \infty$.
\item Для очередного ключа $k$ и значения функции $R(k)$ вычислим \mbox{$sl = R(k) / (k - s_{min})$}.
    \begin{enumerate}
    \item Если \mbox{$slLow < sl < slHigh$}, обновить значения:
    
    \mbox{$slHigh = min(slHigh, (R(k) + e) / (k - s_{min}))$}, \mbox{$slLow = max(slLow, (R(k) - e) / (k - s_{min}))$} и перейти к шагу 3.
    \item Иначе сегмент $s$ выделен, начать построение нового сегмента перейдя к шагу 1.
    \end{enumerate}
\end{enumerate}

Используя данный подход, множество ключей $K$ разбивается на \textbf{сегменты}, каждый из которых свидетельствует о некоторой закономерности в распределении ключей, которые находится внутри данного сегмента. Далее каждый \textbf{сегмент разбивается на блоки} одинаковой длины, размер блока $b_{size}$ внутри сегмента определяется как:
\begin{equation}\label{eq:partition_size}
    b_{size} = \frac{s_{size}}{R(s_{max}) - R(s_{min}) + 1}
\end{equation}

Таким образом, вероятность ложноположительного ответа $b_{fpr}$ для блока:
\begin{equation}\label{eq:partition_fpr}
    b_{fpr} = 1 - \frac{1}{R(b_{max}) - R(b_{min})}
\end{equation}

Любой ключ принадлежит ровно одному блоку, таким образом это есть вероятность ошибки для одного любого ключа.
