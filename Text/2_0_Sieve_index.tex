\section{Сито-индекс и его внедрение в систему доступа к данным}

Для решения задачи пропуска нерелевантных файлов для интервальных запросов необходимо внедрить структуру данных, которая будет одновременно иметь небольшой размер относительно размера индексируемого атрибута \fbox{ссылка на требования}, то есть иметь размер индекса на ключ \fbox{ссылка на формулу} такой, при котором накладные расходы на хранение и доступ к индексу не приведут к тому, что выполнение запроса с использованием индекса будет медленнее выполнения запроса без использования этого же индекса.

Стоит обратить внимание, что в постановке задачи \fbox{ссылка на параграф 1.1} данные в каждом файле имеют некоторую закономерность, например, еще раз рассмотрим случай, когда упрощенные сводки (\ref{column_stats}) дают ложноположительный ответ: файл может содержать в качестве значений отметки времени за только январь и только за декабрь определенного года. Тогда для запросов, нацеленных на извлечение данных за определенные периоды, например, с июня по август того же года, упрощенные сводки дадут ложноположительный ответ для данного файла.

Существуют эвристические подходы для построения индексов, которые используют закономерности в данных. Например, подход Sieve, который основан на наблюдении, что \textbf{близкие по значению ключи часто находятся в одном и том же наборе данных}, или распределены среди различных файлов данных \cite{Sieve}. Именно данное предположение отражают те случаи, когда упрощенные сводки дают ложноположительные ответы, так как упрощенные сводки никак не учитывают реальное расположение данных внутри каждого файла.

Sieve предлагает следующую модель для определения закономерности в распределении данных:

Пусть $k$ --- ключ на множестве ключей $K$, тогда введем функцию R:
\begin{equation}\label{R_CDF}
R(k) = 
\begin{cases} 
    R(k - 1), & \text{если множества расположений $k$ и $k - 1$ равны}, \\
    R(k - 1) + 1, & \text{в остальных случая }.
\end{cases}
\end{equation}

Значение функции $R$ есть общее количество раз, когда набор расположений изменялся для двух соседних ключей. Далее производится линеаризация отдельных сегментов данной функции. Таким образом каждый сегмент отражает некоторую закономерность в распределении ключей между файлами. Например, если линеаризованный участок (сегмент) параллелен оси абсцисс, это значит, что для множество расположений ключей в данном сегменте не менялось, соответственно для того чтобы сохранить информацию о данном сегменте можно использовать меньше памяти, достаточно сохранить минимальное и максимальное значений ключей для данного сегмента и множество расположений, в которых ключи из этого промежутка расположены, и напротив, если тангенс угла линеаризованного участка равен единице, это значит, что расположения ключей различаются для каждых соседних ключей, то есть этот участком необходимо разделить на более мелкие блоки, каждый из которых должен содержать информацию о минимальном и максимальном значении ключей каждого блока и множество расположений этих ключей, для того чтобы снизить вероятность ложноположительных ответов для этого сегмента.

Существует множество вариантов линеаризации сегментов функции R, однако модель Sieve предлагает следующий вариант: \fbox{какой вариант? + PR + ошибка}

Используя данный подход множество ключей $K$ разбивается на \textbf{сегменты}, каждый из которых свидетельствует о некоторой закономерности в распределении ключей, которые находится внутри данного сегмента. Далее каждый \textbf{сегмент разбивается на блоки} одинаковой длины, размер блока $b_{size}$ определяется как:
\begin{equation}\label{partition_size}
    b_{size} = \frac{s_{size}}{R(s_{max}) - R(s_{min}) + 1}
\end{equation}

Где $s_{min}$ --- минимальное значение ключа в сегменте, $s_{max}$ --- максимальное значение ключа в сегменте, а $s_{size} = s_{max} - s_{min}$ -- размер сегмента.

Таким образом, вероятность ложноположительного ответа $b_{fpr}$ для блока:
\begin{equation}\label{partition_fpr}
    \begin{gathered}
    b_{fpr} = 1 - \frac{1}{R(b_{max}) - R(b_{min})} =\\
    = 1 - \frac{1}{(PR(b_{max}) + \varepsilon) - (PR(b_{min}) - \varepsilon)} = 1 - \frac{1}{2\varepsilon}
    \end{gathered}
\end{equation}

Любой ключ принадлежит ровно одному блоку, таким образом это есть вероятность ошибки для одного любого ключа.

Используя данный подход, реализуем структуру данных, которую назовем \textbf{<<Сито-индекс>>}. Данная структура будет состоять из сегментов, каждый из которых будет представлен отдельным файлом в хранилище данных. Каждый такой файл будет содержать в себе набор блоков. Далее подробнее опишем операции над данной структурой данных, принимая ввиду ограничения платформ для обработки больших данных \ref{requirements}.

\fbox{что такое в итоге сегмент и блок, + картинка Сито индекса?}
